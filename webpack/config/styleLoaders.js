// const ExtractTextPlugin = require('extract-text-webpack-plugin');

const isProduction = process.env.NODE_ENV === 'production';
const supportedBrowserList = [
    '> 0.75%',
    'last 3 versions',
    'iOS > 7',
    'Android > 4',
    'last 1 and_ff versions',
    'Firefox ESR',
    'not ie < 9' // React doesn't support IE8 anyway
];

// Plain style loader
const styleLoader = require.resolve('style-loader');

const cssLoader = (isModule) => {
    const loader = {
        loader: require.resolve('css-loader'),
        options: {
            importLoaders: 2,
            minimize: isProduction,
            sourceMap: true
        }
    };
    if (isModule) {
        Object.assign(loader.options, {
            modules: true,
            importLoaders: 2,
            localIdentName: '[local]_[hash:8]'
        });
    }
    return loader;
};

// Plain sass loader
const sassLoader = {
    loader: require.resolve('sass-loader'),
    options: {
        sourceMap: true
    }
};

const resolveUrlLoader = {
    loader: require.resolve('resolve-url-loader')
};

// "postcss" loader applies autoprefixer to our CSS.
// "css" loader resolves paths in CSS and adds assets as dependencies.
// "style" loader turns CSS into JS modules that inject <style> tags.
// In development and production, we use a plugin to extract that CSS to a file
const postCssLoader = () => {
    /* eslint-disable global-require */
    const postCss = {
        loader: require.resolve('postcss-loader'),
        options: {
            ident: 'postcss',
            // If a previous loader like e.g sass-loader is applied and it's sourceMap option is set true,
            // but the sourceMap option in postcss-loader is also set true,
            // previous source maps generated by sass-loader will be discarded by postcss-loader entirely.
            // so set sourceMap with inline in postcss-loader will insert the previous source maps(sass-loader)
            // into css file which is outputed by webpack as a DataUR.
            sourceMap: 'inline',
            plugins: () => [
                require('postcss-flexbugs-fixes'),
                require('autoprefixer')({
                    browsers: supportedBrowserList,
                    flexbox: 'no-2009'
                })
            ]
        }
    };
    return postCss;
    /* eslint-disable global-require */
};

const getExtractTextPluginOptions = (paths, cssFileName) => {
    const publicPath = paths.servedPath;
    // Some apps do not use client-side routing with pushState.
    // For these, "homepage" can be set to "." to enable relative asset paths.
    const shouldUseRelativeAssetPaths = publicPath === './';
    // ExtractTextPlugin expects the build output to be flat.
    // (See https://github.com/webpack-contrib/extract-text-webpack-plugin/issues/27)
    // However, our output is structured with css, js and media folders.
    // To have this structure working with relative paths, we have to use custom options.
    const extractTextPluginOptions = shouldUseRelativeAssetPaths
        ? // Making sure that the publicPath goes back to to build folder.
        {publicPath: Array(cssFileName.split('/').length).join('../')} //eslint-disable-line
        : {};
    return extractTextPluginOptions;
};

const extractSassRules = (paths, extractTextPlugin, isModule) => {
    const regex = isModule ? /^((?!global).)*(scss|css)$/ : /.*global\.(scss|css)$/;
    let loader = extractTextPlugin.extract(
        Object.assign({
            fallback: styleLoader,
            use: [
                cssLoader(isModule),
                postCssLoader(),
                resolveUrlLoader,
                sassLoader
            ]},
        getExtractTextPluginOptions(paths, extractTextPlugin.filename)
        )
    );
    // css reload with HMR
    if (!isProduction) {
        loader = ['css-hot-loader'].concat(loader);
    }

    return {
        test: regex,
        loader
    };
};

module.exports = extractSassRules;
